##  7Redo Transport Services {#GUID-0EC71C7D-A80B-40AA-93E5-28BB7E24ED31} 

An Oracle Data Guard configuration requires that Oracle redo transport services be configured and monitored. 

See the following topics: 

  * [ Introduction to Redo Transport Services ](oracle-data-guard-redo-transport-services.md#GUID-04851F96-F8F3-4999-AAAD-83C4C3C7AE14)

  * [ Configuring Redo Transport Services ](oracle-data-guard-redo-transport-services.md#GUID-8575AE63-9583-4149-9EDF-F4FD9E62B70A)

  * [ Cascaded Redo Transport Destinations ](oracle-data-guard-redo-transport-services.md#GUID-34BCB162-D996-4678-97F1-497805764950)

  * [ Data Protection Considerations for Cascading Standbys ](oracle-data-guard-redo-transport-services.md#GUID-988FF469-5815-4FC3-B529-AE1BE9ACD67B)

  * [ Validating a Configuration ](oracle-data-guard-redo-transport-services.md#GUID-A0AAA20B-4DF8-4698-A7E0-3BED5A2C11E9)

  * [ Monitoring Redo Transport Services ](oracle-data-guard-redo-transport-services.md#GUID-282DA542-4C7C-40E2-A3CB-6486CDCF0C0A)

  * [ Tuning Redo Transport ](oracle-data-guard-redo-transport-services.md#GUID-665E1862-E9F2-4CB2-BFF5-B5F741FD475E)




###  Introduction to Redo Transport Services {#GUID-04851F96-F8F3-4999-AAAD-83C4C3C7AE14} 

Redo transport services  performs the automated transfer of redo data between members of an Oracle Data Guard configuration and other databases. 

The following redo transport destinations are supported: 

  * Oracle Data Guard standby databases 

This guide describes how to create and manage physical, logical, and snapshot standby databases. 

  * Oracle Data Guard primary databases 

This destination is supported only with Oracle Data Guard broker. A primary database is used as a redo transport destination to provide data protection for one or more pluggable databases (PDBs) within a database. 

  * Archive log repository 

This destination type is used for temporary offsite storage of archived redo log files. An archive log repository consists of an Oracle database instance and a physical standby control file. An archive log repository does not contain data files, so it cannot support role transitions. 

The procedure used to create an archive log repository is identical to the procedure used to create a physical standby database, except for the copying of data files. 

  * Oracle Streams downstream capture databases 

  * Far sync instances 

See [ Using Far Sync Instances ](creating-oracle-data-guard-far-sync-instance.md#GUID-8AD7FBA2-42B0-46CF-852B-1AF0CB4A36E8) for more information about far sync instances. 

  * Zero Data Loss Recovery Appliance (Recovery Appliance) 




Each redo transport destination is individually configured to receive redo data via one of two redo transport modes: 

  * Synchronous 

The synchronous redo transport mode transmits redo data synchronously with respect to transaction commitment. A transaction cannot commit until all redo generated by that transaction has been successfully sent to every enabled redo transport destination that uses the synchronous redo transport mode. 

Although there is no limit on the distance between a primary database and a ` SYNC ` redo transport destination, transaction commit latency increases as network latency increases between a primary database and a ` SYNC ` redo transport destination. 

This transport mode is used by the Maximum Protection and Maximum Availability data protection modes described in [ Oracle Data Guard Protection Modes ](oracle-data-guard-protection-modes.md#GUID-16298839-9B8A-4E58-8EC9-27912E57F1CE) . 

> **note:** 

Synchronous redo transport is not supported for Zero Data Loss Recovery Appliance. 

  * Asynchronous 

The asynchronous redo transport mode transmits redo data asynchronously with respect to transaction commitment. A transaction can commit without waiting for the redo generated by that transaction to be successfully sent to any redo transport destination that uses the asynchronous redo transport mode. 

This transport mode is used by the Maximum Performance data protection mode described in [ Oracle Data Guard Protection Modes ](oracle-data-guard-protection-modes.md#GUID-16298839-9B8A-4E58-8EC9-27912E57F1CE) . 




###  Configuring Redo Transport Services {#GUID-8575AE63-9583-4149-9EDF-F4FD9E62B70A} 

Oracle databases must be configured before they can send and receive redo data. Part of the configuration process involves setting up redo transport security. 

See the following topics: 

  * [ Redo Transport Security ](oracle-data-guard-redo-transport-services.md#GUID-FA3B203C-D28E-4A27-8585-9EBC19836F4C)

  * [ Configuring an Oracle Database to Send Redo Data ](oracle-data-guard-redo-transport-services.md#GUID-45DFFA7C-3967-4B46-8C2C-DBD22A4D6A74)

  * [ Configuring an Oracle Database to Receive Redo Data ](oracle-data-guard-redo-transport-services.md#GUID-AF64C4FE-2D16-4197-953A-25930F36CFA8)




These topics assume that you have a thorough understanding of the following: 

  * Database administrator authentication 

  * Database initialization parameters 

  * Managing a redo log 

  * Managing archived redo logs 

  * Fast recovery areas 

  * Oracle Net Configuration 




####  Redo Transport Security {#GUID-FA3B203C-D28E-4A27-8585-9EBC19836F4C} 

Redo transport uses Oracle Net sessions to transport redo data. 

These redo transport sessions are authenticated using either the Secure Socket Layer (SSL) protocol or a remote login password file. 

#####  Redo Transport Authentication Using SSL {#GUID-DB2E46B2-2A4B-4DF0-B925-F07497F3C6A5} 

Secure Sockets Layer (SSL) is an industry standard protocol for securing network connections. 

SSL uses RSA public key cryptography and symmetric key cryptography to provide authentication, encryption, and data integrity. SSL is automatically used for redo transport authentication between two Oracle databases if: 

  * The databases are members of the same Oracle Internet Directory (OID) enterprise domain and that domain allows the use of current user database links. 

  * The ` LOG_ARCHIVE_DEST_ ` *n* , and ` FAL_SERVER ` database initialization parameters that correspond to the databases use Oracle Net connect descriptors configured for SSL. 

  * Each database has an Oracle wallet or a supported hardware security module that contains a user certificate with a distinguished name (DN) that matches the DN in the OID entry for the database. 




> **note:** See Also: 

  * [ *Oracle Database Security Guide* ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=DBSEG070) for more information about SSL 

  * [ *Oracle Database Security Guide* ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=DBIMI130) for more information about administering enterprise domains 

  * [ *Oracle Label Security Administrator's Guide* ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=OLSAG026) for information about administering Oracle Internet Directory 




#####  Redo Transport Authentication Using a Password File {#GUID-6BF40A23-66E3-42C8-9CF5-DE715F648CD4} 

If the SSL authentication requirements are not met, then each database must use a remote login password file. 

In an Oracle Data Guard configuration, all physical and snapshot standby databases must use a copy of the password file from the primary database. If database compatibility is set to 12.2 or higher on both the source and target database, then the copy of the password file is automatically refreshed whenever an administrative privilege ( ` SYSDG ` , ` SYSOPER ` , ` SYSDBA ` , and so on) is granted or revoked, and after the password of any user with administrative privileges is changed. The only exception to this is far sync instances. Updated password files must still be manually copied to far sync instances because far sync instances receive redo, but do not apply it. Once the password file is up-to-date at the far sync instance the redo containing the password update at the primary is automatically propagated to any standby databases that are set up to receive redo from that far sync instance. The password file is updated on the standby when the redo is applied. 

When a password file is used for redo transport authentication, the password of the user account used for redo transport authentication is compared between the database initiating a redo transport session and the target database. The password must be the same at both databases to create a redo transport session. 

By default, the password of the ` SYS ` user is used to authenticate redo transport sessions when a password file is used. The ` REDO_TRANSPORT_USER ` database initialization parameter can be used to select a different user password for redo transport authentication by setting this parameter to the name of any user who has been granted the ` SYSOPER ` privilege. For administrative ease, Oracle recommends that the ` REDO_TRANSPORT_USER ` parameter be set to the same value on the redo source database and at each redo transport destination. 

> **note:** See Also: 

[ *Oracle Database Administrator's Guide* ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=ADMIN001) for more information creating and maintaining remote login password files 

####  Configuring an Oracle Database to Send Redo Data {#GUID-45DFFA7C-3967-4B46-8C2C-DBD22A4D6A74} 

To specify a redo transport destination, use the ` LOG_ARCHIVE_DEST_ ` *n* database initialization parameter (where *n* is an integer from 1 to 31). 

> **note:** 

Configuring redo transport services to provide protection for one or more pluggable databases (PDBs) is supported through Oracle Data Guard broker only. 

There is a ` LOG_ARCHIVE_DEST_STATE_ ` *n* database initialization parameter (where *n* is an integer from 1 to 31) that corresponds to each ` LOG_ARCHIVE_DEST_ ` *n* parameter. This parameter is used to enable or disable the corresponding redo destination. [ Table 7-1 ](oracle-data-guard-redo-transport-services.md#GUID-45DFFA7C-3967-4B46-8C2C-DBD22A4D6A74__BABGFCHH) shows the valid values that can be assigned to this parameter. 

**Table: LOG_ARCHIVE_DEST_STATE_n Initialization Parameter Values** 

Value  |  Description   
---|---  
` ENABLE ` |  Redo transport services can transmit redo data to this destination. This is the default.   
` DEFER ` |  Redo transport services do not transmit redo data to this destination.   
` ALTERNATE ` |  This destination becomes enabled if communication to its associated destination fails.   
  
A redo transport destination is configured by setting the ` LOG_ARCHIVE_DEST_ ` *n* parameter to a character string that includes one or more attributes. This section briefly describes the most commonly used attributes. See [ LOG_ARCHIVE_DEST_n Parameter Attributes ](LOG_ARCHIVE_DEST_n-parameter-attributes.md#GUID-B04FC22C-F0B0-440F-BAF4-182EE547FCC1) for a full description of all ` LOG_ARCHIVE_DEST_ ` *n* parameter attributes. 

The ` SERVICE ` attribute, which is a mandatory attribute for a redo transport destination, must be the first attribute specified in the attribute list. The ` SERVICE ` attribute is used to specify the Oracle Net service name used to connect to the redo transport destination. The service name must be resolvable through an Oracle Net naming method to an Oracle Net connect descriptor that matches the Oracle Net listener(s) at the redo transport destination. The connect descriptor must specify that a dedicated server connection be used, unless that is the default connection type for the redo transport destination. 

> **note:** See Also: 

[ *Oracle Database Net Services Administrator's Guide* ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=NETAG006) for information about Oracle Net service names, connect descriptors, listeners, and network security 

The ` SYNC ` attribute specifies that the synchronous redo transport mode be used to send redo data to a redo transport destination. 

The ` ASYNC ` attribute specifies that the asynchronous redo transport mode be used to send redo data to a redo transport destination. The asynchronous redo transport mode is used if neither the ` SYNC ` nor the ` ASYNC ` attribute is specified. 

The ` NET_TIMEOUT ` attribute specifies how long the ` LGWR ` process waits for an acknowledgement that redo data has been successfully received by a destination that uses the synchronous redo transport mode. If an acknowledgement is not received within ` NET_TIMEOUT ` seconds, the redo transport connection is terminated and an error is logged. 

Oracle recommends that the ` NET_TIMEOUT ` attribute be specified whenever the synchronous redo transport mode is used, so that the maximum duration of a redo source database stall caused by a redo transport fault can be precisely controlled. See [ Monitoring Synchronous Redo Transport Response Time ](oracle-data-guard-redo-transport-services.md#GUID-666D0186-B639-4DB2-9993-D1947230C50F) for information about monitoring synchronous redo transport mode response time. 

> **note:** You could also set the database initialization parameter, ` DATA_GUARD_SYNC_LATENCY ` , which is global for all synchronous standby destinations. It defines the maximum amount of time (in seconds) that the primary database may wait before disconnecting subsequent destinations after at least one synchronous standby has acknowledged receipt of the redo. 

For example, suppose you have three synchronous standby destinations and you set ` DATA_GUARD_SYNC_LATENCY ` to a value of 2. If the first standby acknowledges receipt of the redo immediately, then the primary database waits no longer than 2 seconds for the other two standbys to respond. If one or both respond within 2 seconds, then they are maintained as active destinations. Destinations that do not respond in time are marked as failed. In both cases the primary remains in zero data loss protection mode because one synchronous standby has acknowledged receipt of the redo. Any failed synchronous standbys are reconnected as normal after the number of seconds specified for the ` REOPEN ` attribute have passed. 

The ` AFFIRM ` attribute is used to specify that redo received from a redo source database is not acknowledged until it has been written to the standby redo log. The ` NOAFFIRM ` attribute is used to specify that received redo is acknowledged without waiting for received redo to be written to the standby redo log. 

The ` DB_UNIQUE_NAME ` attribute is used to specify the ` DB_UNIQUE_NAME ` of a redo transport destination. The ` DB_UNIQUE_NAME ` attribute must be specified if the ` LOG_ARCHIVE_CONFIG ` database initialization parameter has been defined and its value includes a ` DG_CONFIG ` list. 

If the ` DB_UNIQUE_NAME ` attribute is specified, its value must match one of the ` DB_UNIQUE_NAME ` values in the ` DG_CONFIG ` list. It must also match the value of the ` DB_UNIQUE_NAME ` database initialization parameter at the redo transport destination. If either match fails, an error is logged and redo transport is not possible to that destination. 

The ` VALID_FOR ` attribute is used to specify when redo transport services transmits redo data to a redo transport destination. Oracle recommends that the ` VALID_FOR ` attribute be specified for each redo transport destination at every site in an Oracle Data Guard configuration so that redo transport services continue to send redo data to all standby databases after a role transition, regardless of which standby database assumes the primary role. 

The ` REOPEN ` attribute is used to specify the minimum number of seconds between automatic reconnect attempts to a redo transport destination that is inactive because of a previous error. 

The ` COMPRESSION ` attribute is used to specify that redo data is transmitted to a redo transport destination in compressed form. Redo transport compression can significantly improve redo transport performance on network links with low bandwidth and high latency. 

Redo transport compression is a feature of the Oracle Advanced Compression option. You must purchase a license for this option before using the redo transport compression feature. 

The following example uses all of the ` LOG_ARCHIVE_DEST_ ` *n* attributes described in this section. A ` DB_UNIQUE_NAME ` has been specified for both destinations, as has the use of compression. If a redo transport fault occurs at either destination, then redo transport attempts to reconnect to that destination, but not more frequently than once every 60 seconds. 
    
    
    ```
    DB_UNIQUE_NAME=BOSTON
    LOG_ARCHIVE_CONFIG='DG_CONFIG=(BOSTON,CHICAGO,HARTFORD)' 
    LOG_ARCHIVE_DEST_2='SERVICE=CHICAGO ASYNC NOAFFIRM VALID_FOR=(ONLINE_LOGFILE, 
    PRIMARY_ROLE) REOPEN=60 COMPRESSION=ENABLE  DB_UNIQUE_NAME=CHICAGO' 
    LOG_ARCHIVE_DEST_STATE_2='ENABLE' 
    LOG_ARCHIVE_DEST_3='SERVICE=HARTFORD SYNC AFFIRM NET_TIMEOUT=30 
    VALID_FOR=(ONLINE_LOGFILE,PRIMARY_ROLE) REOPEN=60 COMPRESSION=ENABLE   
    DB_UNIQUE_NAME=HARTFORD' 
    LOG_ARCHIVE_DEST_STATE_3='ENABLE'
    
    ```

> **note:** 

Configuration for Zero Data Loss Recovery Appliance (Recovery Appliance) is identical to configuration for any standby database. So in the preceding example, because Chicago is an ` ASYNC ` destination, it could be either a standby database or a Recovery Appliance. (Synchronous redo transport is not supported for Recovery Appliance) 

**Related Topics**

  * [ Oracle Data Guard Broker Configurations ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=DGBKR-GUID-FBEC1B54-CEE8-4634-89AD-55FDDB0EA023)



#####  Viewing Attributes With V$ARCHIVE_DEST {#GUID-DC156D33-A034-4766-85BF-ADF414C19945} 

The ` V$ARCHIVE_DEST ` view can be queried to see the current settings and status for each redo transport destination. 

####  Configuring an Oracle Database to Receive Redo Data {#GUID-AF64C4FE-2D16-4197-953A-25930F36CFA8} 

Redo transport destination must be configured to receive and to archive redo data from a redo source database. 

See the following: 

  * [ Managing Standby Redo Logs ](oracle-data-guard-redo-transport-services.md#GUID-E6EC6104-3C38-482D-B807-A0E84ECFB937)

  * [ Cases Where Redo Is Written Directly To an Archived Redo Log File ](oracle-data-guard-redo-transport-services.md#GUID-7F508757-E1BA-4608-8D0E-946C3C765F61)




**Related Topics**

  * [ Oracle Data Guard Broker Configurations ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=DGBKR-GUID-FBEC1B54-CEE8-4634-89AD-55FDDB0EA023)



#####  Managing Standby Redo Logs {#GUID-E6EC6104-3C38-482D-B807-A0E84ECFB937} 

The synchronous and asynchronous redo transport modes require that a redo transport destination have a standby redo log. A standby redo log  is used to store redo received from another Oracle database. Standby redo logs are structurally identical to redo logs, and are created and managed using the same SQL statements used to create and manage redo logs. 

Redo received from another Oracle database via redo transport is written to the current standby redo log group by a remote file server (RFS) foreground process. When a log switch occurs on the redo source database, incoming redo is then written to the next standby redo log group, and the previously used standby redo log group is archived by an ` ARC ` *n* background process. 

The process of sequentially filling and then archiving redo log file groups at a redo source database is mirrored at each redo transport destination by the sequential filling and archiving of standby redo log groups. 

Each standby redo log file must be at least as large as the largest redo log file in the redo log of the redo source database. For administrative ease, Oracle recommends that all redo log files in the redo log at the redo source database and the standby redo log at a redo transport destination be of the same size. 

The standby redo log must have at least one more redo log group than the redo log at the redo source database, for each redo thread at the redo source database. At the redo source database, query the ` V$LOG ` view to determine how many redo log groups are in the redo log at the redo source database and query the ` V$THREAD ` view to determine how many redo threads exist at the redo source database. 

Perform the following query on a redo source database to determine the size of each log file and the number of log groups in the redo log: 
    
    
    ```
    SQL> SELECT GROUP#, BYTES FROM V$LOG;
    
    ```

Perform the following query on a redo destination database to determine the size of each log file and the number of log groups in the standby redo log: 
    
    
    ```
    SQL> SELECT GROUP#, BYTES FROM V$STANDBY_LOG;
    
    ```

If the redo source database is an Oracle Real Applications Cluster (Oracle RAC) or Oracle Real Application Clusters One Node (Oracle RAC One Node) database, query the ` V$LOG ` view at the redo source database to determine how many redo threads exist and specify the corresponding thread numbers when adding redo log groups to the standby redo log. 

The following sample SQL statements create a standby redo log at a database that is to receive redo from a redo source database that has two redo threads: 
    
    
    ```
    SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 500M;
    SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 500M;
    SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 1 SIZE 500M;
    SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 500M;
    SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 500M;
    SQL> ALTER DATABASE ADD STANDBY LOGFILE THREAD 2 SIZE 500M;
    ```

> **note:** 

Whenever a redo log group is added to a primary database, a log group must also be added to the standby redo log of each standby database in the configuration. Otherwise, the standby database may become unsynchronized after a primary log switch, which could temporarily prevent a zero data loss failover or cause a primary database operating in maximum protection mode to shut down. 

#####  Cases Where Redo Is Written Directly To an Archived Redo Log File {#GUID-7F508757-E1BA-4608-8D0E-946C3C765F61} 

Redo received by a standby database is written directly to an archived redo log file if a standby redo log group is not available or if the redo was sent to resolve a redo gap. When this occurs, redo is written to the location specified by the ` LOCATION ` attribute of one ` LOG_ARCHIVE_DEST_ ` *n* parameter that is valid for archiving redo received from another database. The ` LOG_ARCHIVE_DEST_ ` *n* parameter that is used for this purpose is determined when the standby database is mounted, and this choice is reevaluated each time a ` LOG_ARCHIVE_DEST_ ` *n* parameter is modified. 

#####  Location of Archived Redo Log Files {#GUID-2D52E44A-A4E9-4D9B-954B-C37330140FAB} 

Certain criteria define where the remote file server (RFS) creates an archived redo log file. 

  * If no local log archive destinations are configured: 

    * When Oracle Managed Files (OMF) is used, the archived redo log file is stored in the fast recovery area. 

    * When OMF is not used, the archived redo log file is stored in the ` /dbs/arch ` directory. 

  * If one or more local log archive destinations are defined, the archived redo log file is stored in the first (lowest) valid, enabled, and active log archive destination that is valid for SRLs and the current role. 

  * If one or more local log archive destinations are defined, but none of them are valid, enabled, and active, the archived redo log file is stored in the ` /dbs/arch ` directory. 




###  Cascaded Redo Transport Destinations {#GUID-34BCB162-D996-4678-97F1-497805764950} 

A cascaded redo transport destination (also known as a terminal destination) receives primary database redo indirectly from a standby database rather than directly from a primary database. 

A physical standby database that cascades primary database redo to one or more terminal destinations at the same time it is applying changes to its local database files is known as a cascading standby database. 

With cascading, the overhead associated with performing redo transport is offloaded from a primary database to a cascading standby database. 

A cascading standby database can cascade primary database redo to up to 30 terminal destinations. 

A cascading standby database can either cascade redo in real-time  (as it is being written to the standby redo log file) or non-real-time (as complete standby redo log files are being archived on the cascading standby). 

Cascading has the following restrictions: 

  * Only physical standby databases can cascade redo. 

  * Real-time cascading requires a license for the Oracle Active Data Guard option. 

  * Non-real-time cascading is supported on destinations 1 through 10 only. (Real-time cascading is supported on all destinations.) 




> **note:** 

See [ Before You Patch or Upgrade the Oracle Database Software ](upgrading-patching-downgrading-oracle-data-guard-configuration.md#GUID-784C06D8-9CFA-4244-BA55-D7003CAB3F1E) for information about how to handle cascaded redo transport destinations during an Oracle Database upgrade. 

Also see the following topics: 

  * [ Configuring a Terminal Destination ](oracle-data-guard-redo-transport-services.md#GUID-10CFB766-F688-4CD8-80CC-7824A522D1DF)

  * [ Cascading Scenarios ](oracle-data-guard-redo-transport-services.md#GUID-5CE6C2AB-86AA-4402-AD7E-0820F3935827)




####  Configuring a Terminal Destination {#GUID-10CFB766-F688-4CD8-80CC-7824A522D1DF} 

These steps describe how to configure a terminal destination. 

  1. Select a physical standby database to configure as a cascading standby database. 
  2. On the cascading standby database, configure the ` FAL_SERVER ` database initialization parameter with the Oracle Net alias of the primary database or of a standby database that receives redo directly from the primary database. 
  3. On the cascading standby database, configure a ` LOG_ARCHIVE_DEST_ ` *n* database initialization parameter for one or more terminal destinations. Configure the ` SERVICE ` attribute of this destination with the Oracle Net alias of the terminal destination, and the ` VALID ` attribute to be valid for archival of the standby redo log while in the standby role. 

If you specify ` ASYNC ` transport mode on destinations 1 through 10, then redo is shipped in real-time. If you do not specify a transport mode or you specify ` SYNC ` on destinations 1 through 10, then redo is shipped in non-real-time. Destinations 11 through 31 operate only in ` ASYNC ` (real-time) transport mode. 

  4. At the terminal destination, configure the ` FAL_SERVER ` database initialization parameter with the Oracle Net alias of the cascading standby database or of another standby database that is directly connected to the primary database. Although it is also possible to specify the primary database, this would defeat the purpose of cascading, which is to reduce the redo transport overhead on the primary database. 
  5. [ Example 7-1 ](oracle-data-guard-redo-transport-services.md#GUID-10CFB766-F688-4CD8-80CC-7824A522D1DF__BEHHDCCI) shows some of the database initialization parameters used by the members of an Oracle Data Guard configuration that includes a primary database named ` boston ` that sends redo to a local physical standby database named ` boston2 ` , which then cascades primary database redo to a remote physical standby database named ` denver ` . 

A ` LOG_ARCHIVE_DEST_ ` *n* database initialization parameter could also be configured on database ` boston ` that is valid for standby redo log archival to database ` denver ` when database ` boston ` is in the standby role. This would allow redo cascading to database ` denver ` to continue if a switchover is performed between database ` boston ` and database ` boston2 ` . 




Example 7-1 Some of the Initialization Parameters Used When Cascading Redo 

Primary  Database 
    
    
    ```
    DB_UNIQUE_NAME=boston
     
    FAL_SERVER=boston2
     
    LOG_ARCHIVE_CONFIG='DG_CONFIG=(boston,boston2,denver)'
     
    LOG_ARCHIVE_DEST_1='LOCATION=USE_DB_RECOVERY_FILE_DEST
    VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=boston'
     
    LOG_ARCHIVE_DEST_2='SERVICE=boston2 SYNC
    VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=boston2'
    
    ```

Cascading Physical Standby Database 
    
    
    ```
    DB_UNIQUE_NAME=boston2
     
    FAL_SERVER=boston
     
    LOG_ARCHIVE_CONFIG= 'DG_CONFIG=(boston,boston2,denver)'
     
    LOG_ARCHIVE_DEST_1='LOCATION= USE_DB_RECOVERY_FILE_DEST
    VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=boston2'
     
    LOG_ARCHIVE_DEST_2= 'SERVICE=denver
    VALID_FOR=(STANDBY_LOGFILES,STANDBY_ROLE) DB_UNIQUE_NAME=denver'
     
    ```

Cascaded Physical Standby Database 
    
    
    ```
    DB_UNIQUE_NAME=denver
     
    FAL_SERVER=boston2
     
    LOG_ARCHIVE_CONFIG='DG_CONFIG=(boston,boston2,denver)'
     
    LOG_ARCHIVE_DEST_1='LOCATION= USE_DB_RECOVERY_FILE_DEST
    VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=denver'
    
    ```

For information about validating a configuration after you set up a cascading environment, see  " [ Validating a Configuration ](oracle-data-guard-redo-transport-services.md#GUID-A0AAA20B-4DF8-4698-A7E0-3BED5A2C11E9) "  . 

####  Cascading Scenarios {#GUID-5CE6C2AB-86AA-4402-AD7E-0820F3935827} 

A Data Guard configuration can be set up to cascade to a single physical standby or to multiple physical standbys. 

See the following topics: 

  * [ Cascading to a Physical Standby ](oracle-data-guard-redo-transport-services.md#GUID-D1F7299F-0924-46AA-B12D-D2579F8E0FCC)

  * [ Cascading to Multiple Physical Standbys ](oracle-data-guard-redo-transport-services.md#GUID-09B8562C-2A31-4B7C-832D-027ED07BE5D4)




#####  Cascading to a Physical Standby {#GUID-D1F7299F-0924-46AA-B12D-D2579F8E0FCC} 

These steps provide an example of cascading to a physical standby database. 

In this scenario, you have a mission-critical primary database. This database has stringent performance and data protection requirements, so you have decided to deploy a local physical standby database to provide zero data loss protection and a remote, cascaded physical standby database to protect against regional disasters at the primary and local standby database sites. 

You can achieve the objectives described above by performing the following steps: 

  1. Create a physical standby database at a local site. 
  2. Create a physical standby database at a site that is sufficiently remote to provide protection against regional disasters at the primary and local standby database sites. 
  3. Configure the local standby database as a ` SYNC ` redo transport destination of the primary database. 
  4. Configure the remote physical standby database as a terminal destination of the local standby database. 



#####  Cascading to Multiple Physical Standbys {#GUID-09B8562C-2A31-4B7C-832D-027ED07BE5D4} 

These steps provide an example of cascading to multiple physical standby databases. 

In this scenario, you have a primary database in North America and you want to deploy three replicas of this database in Europe to support read-only reporting applications. For cost and performance reasons, you do not want to maintain network links from North America to each of your European sites. 

You can achieve the objectives described above by performing the following steps: 

  1. Create a network link between your North American site and one of your European sites. 
  2. Create a physical standby database at each of your European sites. 
  3. Open your physical standby databases in real-time query mode, as described in [ Opening a Physical Standby Database ](managing-oracle-data-guard-physical-standby-databases.md#GUID-D5FB88EC-799D-40E7-80E1-19474E3167E4) . 
  4. Configure the physical standby database at the European endpoint of your transatlantic network link to cascade redo to your other European standby databases. 
  5. Configure the other two physical standby databases as terminal destinations of the cascading standby database configured in step 4. 



###  Data Protection Considerations for Cascading Standbys {#GUID-988FF469-5815-4FC3-B529-AE1BE9ACD67B} 

When your configuration includes cascading standbys, each destination should have a ` LOG_ARCHIVE_DEST_ ` *n* parameter defined that points back to its source for use during a failover. 

Real-time cascade enables a cascaded standby database to provide nearly the same level of data protection as any standby database that receives redo directly from a primary database using asynchronous redo transport. However, although redo is forwarded in real-time, the fact that there is a second network hop creates the potential for additional data loss if an outage prevents all redo from reaching the terminal destination. 

###  Validating a Configuration {#GUID-A0AAA20B-4DF8-4698-A7E0-3BED5A2C11E9} 

To validate an Oracle Data Guard configuration after you create it, query the ` V$DATAGUARD_CONFIG ` view from any database in the configuration. 

The view displays the unique database names defined with the ` DB_UNIQUE_NAME ` and ` LOG_ARCHIVE_CONFIG ` initialization parameters. 

> **note:** See Also: 

  * [ *Oracle Database Reference* ](https://docs.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sbydb&id=REFRN30053) for more information about the ` V$DATAGUARD_CONFIG ` view 




###  Monitoring Redo Transport Services {#GUID-282DA542-4C7C-40E2-A3CB-6486CDCF0C0A} 

You can monitor redo transport status, as well as redo transport response time. 

See the following topics: 

  * [ Monitoring Redo Transport Status ](oracle-data-guard-redo-transport-services.md#GUID-A9239CAA-DCE9-4108-9516-980FF37A3AE5)

  * [ Monitoring Synchronous Redo Transport Response Time ](oracle-data-guard-redo-transport-services.md#GUID-666D0186-B639-4DB2-9993-D1947230C50F)

  * [ Redo Gap Detection and Resolution ](oracle-data-guard-redo-transport-services.md#GUID-05CE1D49-3DEE-4AAC-A887-55ED436912AF)

  * [ Redo Transport Services Wait Events ](oracle-data-guard-redo-transport-services.md#GUID-EB15DAF9-40A8-4185-B4C2-F8BB4FBD33CE)




####  Monitoring Redo Transport Status {#GUID-A9239CAA-DCE9-4108-9516-980FF37A3AE5} 

You can query views to monitor redo transport status on a redo source database. 

Take the following steps to monitor redo transport status on a redo source database. 

  1. Perform the following query on the redo source database to determine the most recently archived sequence number for each thread: 
    
        ```
    SQL> SELECT MAX(SEQUENCE#), THREAD# FROM V$ARCHIVED_LOG -
    > WHERE RESETLOGS_CHANGE# = (SELECT MAX(RESETLOGS_CHANGE#) FROM V$ARCHIVED_LOG) -
    > GROUP BY THREAD#;
    
    ```

  2. Perform the following query on the redo source database to determine the most recently archived redo log file at each redo transport destination: 
    
        ```
    SQL> SELECT DESTINATION, STATUS, ARCHIVED_THREAD#, ARCHIVED_SEQ# -
    > FROM V$ARCHIVE_DEST_STATUS -
    > WHERE STATUS <> 'DEFERRED' AND STATUS <> 'INACTIVE';
     
    DESTINATION         STATUS  ARCHIVED_THREAD#  ARCHIVED_SEQ#
    ------------------  ------  ----------------  -------------
    /private1/prmy/lad   VALID                 1            947
    standby1             VALID                 1            947
    
    ```

The most recently archived redo log file should be the same for each destination. If it is not, a status other than ` VALID ` may identify an error encountered during the archival operation to that destination. 

  3. Perform a query at a redo source database to find out if an archived redo log file has been received at a particular redo transport destination. Each destination has an ID number associated with it. You can query the ` DEST_ID ` column of the ` V$ARCHIVE_DEST ` view on a database to identify each destination's ID number. 

Assume that destination 1 points to the local archived redo log and that destination 2 points to a redo transport destination. Perform the following query at the redo source database to find out if any log files are missing at the redo transport destination: 
    
        ```
    SQL> SELECT LOCAL.THREAD#, LOCAL.SEQUENCE# FROM -
    > (SELECT THREAD#, SEQUENCE# FROM V$ARCHIVED_LOG WHERE DEST_ID=1) -
    > LOCAL WHERE -
    > LOCAL.SEQUENCE# NOT IN -
    > (SELECT SEQUENCE# FROM V$ARCHIVED_LOG WHERE DEST_ID=2 AND -
    > THREAD# = LOCAL.THREAD#);
     
    THREAD#    SEQUENCE#
    ---------  ---------
      1        12
      1        13
      1        14
    ```

  4. Set the ` LOG_ARCHIVE_TRACE ` database initialization parameter at a redo source database and at each redo transport destination to trace redo transport progress. See [ Setting Archive Tracing ](setting-LOG_ARCHIVE_TRACE-initialization-parameter.md#GUID-515A27B2-5163-42E1-A78D-B6E979BA54EB) for complete details and examples. 



####  Monitoring Synchronous Redo Transport Response Time {#GUID-666D0186-B639-4DB2-9993-D1947230C50F} 

The ` V$REDO_DEST_RESP_HISTOGRAM ` view contains response time data for each redo transport destination. 

The response time data is maintained for redo transport messages sent via the synchronous redo transport mode. 

The data for each destination consists of a series of rows, with one row for each response time. To simplify record keeping, response times are rounded up to the nearest whole second for response times less than 300 seconds. Response times greater than 300 seconds are round up to 600, 1200, 2400, 4800, or 9600 seconds. 

Each row contains four columns: ` FREQUENCY ` , ` DURATION ` , ` DEST_ID ` , and ` TIME ` . 

The ` FREQUENCY ` column contains the number of times that a given response time has been observed. The ` DURATION ` column corresponds to the response time. The ` DEST_ID ` column identifies the destination. The ` TIME ` column contains a timestamp taken when the row was last updated. 

The response time data in this view is useful for identifying synchronous redo transport mode performance issues that can affect transaction throughput on a redo source database. It is also useful for tuning the ` NET_TIMEOUT ` attribute. 

The next three examples show example queries for destination 2, which corresponds to the ` LOG_ARCHIVE_DEST_2 ` parameter. To display response time data for a different destination, simply change the ` DEST_ID ` in the query. 

Perform the following query on a redo source database to display the response time histogram for destination 2: 
    
    
    ```
    SQL> SELECT FREQUENCY, DURATION FROM -
    > V$REDO_DEST_RESP_HISTOGRAM WHERE DEST_ID=2 AND FREQUENCY>1;
    
    ```

Perform the following query on a redo source database to display the slowest response time for destination 2: 
    
    
    ```
    SQL> SELECT max(DURATION) FROM V$REDO_DEST_RESP_HISTOGRAM -
    > WHERE DEST_ID=2 AND FREQUENCY>1;
    
    ```

Perform the following query on a redo source database to display the fastest response time for destination 2: 
    
    
    ```
    SQL> SELECT min( DURATION) FROM V$REDO_DEST_RESP_HISTOGRAM -
    > WHERE DEST_ID=2 AND FREQUENCY>1;
    ```

> **note:** 

The highest observed response time for a destination cannot exceed the highest specified ` NET_TIMEOUT ` value specified for that destination, because synchronous redo transport mode sessions are terminated if a redo transport destination does not respond to a redo transport message within ` NET_TIMEOUT ` seconds. 

####  Redo Gap Detection and Resolution {#GUID-05CE1D49-3DEE-4AAC-A887-55ED436912AF} 

A redo gap occurs whenever redo transmission is interrupted. 

When redo transmission resumes, redo transport services automatically detects the redo gap and resolves it by sending the missing redo to the destination. 

The time needed to resolve a redo gap is directly proportional to the size of the gap and inversely proportional to the effective throughput of the network link between the redo source database and the redo transport destination. Use redo transport compression to reduce the redo gap resolution time. The ` COMPRESSION ` attribute of the ` LOG_ARCHIVE_DEST_ ` *n* parameter is used to specify that redo data be compressed before transmission to the destination. 

See [ LOG_ARCHIVE_DEST_n Parameter Attributes ](LOG_ARCHIVE_DEST_n-parameter-attributes.md#GUID-B04FC22C-F0B0-440F-BAF4-182EE547FCC1) for more information about the ` COMPRESSION ` attribute. 

#####  Manual Gap Resolution {#GUID-97EB433B-4125-4082-9276-2454349BC4F8} 

In some situations, gap resolution cannot be performed automatically and it must be performed manually. 

For example, redo gap resolution must be performed manually on a logical standby database if the primary database is unavailable. 

Perform the following query at the physical standby database to determine if there is redo gap on a physical standby database: 
    
    
    ```
    SQL> SELECT * FROM V$ARCHIVE_GAP;
    
        THREAD# LOW_SEQUENCE# HIGH_SEQUENCE#
    -----------  -------------  --------------
              1              7              10
    
    ```

The output from the previous example indicates that the physical standby database is currently missing log files from sequence 7 to sequence 10 for thread 1. 

Perform the following query on the primary database to locate the archived redo log files on the primary database (assuming the local archive destination on the primary database is ` LOG_ARCHIVE_DEST_1 ` ): 
    
    
    ```
    SQL> SELECT NAME FROM V$ARCHIVED_LOG WHERE THREAD#=1 AND -
    > DEST_ID=1 AND SEQUENCE# BETWEEN 7 AND 10;
    
    NAME
    --------------------------------------------------------------------------------
    /primary/thread1_dest/arcr_1_7.arc 
    /primary/thread1_dest/arcr_1_8.arc 
    /primary/thread1_dest/arcr_1_9.arc
    ```

> **note:** 

This query may return consecutive sequences for a given thread. In that case, there is no actual gap, but the associated thread was disabled and enabled within the time period of generating these two archived logs. The query also does not identify the gap that may exist at the tail end for a given thread. For instance, if the primary database has generated archived logs up to sequence 100 for thread 1, and the latest archived log that the logical standby database has received for the given thread is the one associated with sequence 77, then this query does not return any rows, although there is a gap for the archived logs associated with sequences 78 to 100. 

Copy these log files to the physical standby database and register them using the ` ALTER DATABASE REGISTER LOGFILE ` command. In a DG PDB configuration that provides data protection for a pluggable database (PDB), connect to the source database, copy the log files to the target database, and register them using the ` ALTER DATABASE REGISTER LOGFILE ` command. 

For example: 
    
    
    ```
    SQL> ALTER DATABASE REGISTER LOGFILE -
    > '/physical_standby1/thread1_dest/arcr_1_7.arc';
    
    SQL> ALTER DATABASE REGISTER LOGFILE -
    > '/physical_standby1/thread1_dest/arcr_1_8.arc';
    
    SQL> ALTER DATABASE REGISTER LOGFILE -
    > '/physical_standby1/thread1_dest/arcr_1_9.arc';
    ```

> **note:** 

The ` V$ARCHIVE_GAP ` view on a physical standby database only returns the gap that is currently blocking Redo Apply from continuing. After resolving the gap, query the ` V$ARCHIVE_GAP ` view again on the physical standby database to determine if there is another gap sequence. Repeat this process until there are no more gaps. 

To determine if there is a redo gap on a logical standby database, query the ` DBA_LOGSTDBY_LOG ` view on the logical standby database. For example, the following query indicates there is a gap in the sequence of archived redo log files because it displays two files for ` THREAD 1 ` on the logical standby database. (If there are no gaps, then the query shows only one file for each thread.) The output shows that the highest registered file is sequence number 10, but there is a gap at the file shown as sequence number 6: 
    
    
    ```
    SQL> COLUMN FILE_NAME FORMAT a55
    SQL> SELECT THREAD#, SEQUENCE#, FILE_NAME FROM DBA_LOGSTDBY_LOG L -
    > WHERE NEXT_CHANGE# NOT IN -
    > (SELECT FIRST_CHANGE# FROM DBA_LOGSTDBY_LOG WHERE L.THREAD# = THREAD#) -
    > ORDER BY THREAD#, SEQUENCE#;
     
       THREAD#  SEQUENCE# FILE_NAME
    ---------- ---------- -----------------------------------------------
             1          6 /disk1/oracle/dbs/log-1292880008_6.arc
             1         10 /disk1/oracle/dbs/log-1292880008_10.arc
    
    ```

Copy the missing log files, with sequence numbers 7, 8, and 9, to the logical standby system and register them using the ` ALTER DATABASE REGISTER LOGICAL LOGFILE ` statement. For example: 
    
    
    ```
    SQL> ALTER DATABASE REGISTER LOGICAL LOGFILE -
    > '/disk1/oracle/dbs/log-1292880008_7.arc'; 
    
    SQL> ALTER DATABASE REGISTER LOGICAL LOGFILE -
    > '/disk1/oracle/dbs/log-1292880008_8.arc';
    
    SQL> ALTER DATABASE REGISTER LOGICAL LOGFILE -
    > '/disk1/oracle/dbs/log-1292880008_9.arc';
    ```

> **note:** 

A query based on the ` DBA_LOGSTDBY_LOG ` view on a logical standby database, as specified above, only returns the gap that is currently blocking SQL Apply from continuing. After resolving the gap, query the ` DBA_LOGSTDBY_LOG ` view again on the logical standby database to determine if there is another gap sequence. Repeat this process until there are no more gaps. 

####  Redo Transport Services Wait Events {#GUID-EB15DAF9-40A8-4185-B4C2-F8BB4FBD33CE} 

You can use Oracle wait events to track redo transport wait time on a redo source database. 

[ Table 7-2 ](oracle-data-guard-redo-transport-services.md#GUID-EB15DAF9-40A8-4185-B4C2-F8BB4FBD33CE__BABHDCCD) lists several of these Oracle wait events, which are found in the ` V$SYSTEM_EVENT ` dynamic performance view. 

For a complete list of the Oracle wait events used by redo transport, see the Oracle Data Guard Redo Transport and Network Best Practices technical brief on the Oracle Maximum Availability Architecture (MAA) home page at: 

[ ` http://www.oracle.com/goto/maa ` ](http://www.oracle.com/goto/maa)

**Table: Redo Transport Wait Events** 

Wait Event  |  Description   
---|---  
LNS wait on ATTACH  |  Total time spent waiting for redo transport sessions to be established to all ` ASYNC ` and ` SYNC ` redo transport destinations   
LNS wait on SENDREQ  |  Total time spent waiting for redo data to be written to all ` ASYNC ` and ` SYNC ` redo transport destinations   
LNS wait on DETACH  |  Total time spent waiting for redo transport connections to be terminated to all ` ASYNC ` and ` SYNC ` redo transport destinations   
  
###  Tuning Redo Transport {#GUID-665E1862-E9F2-4CB2-BFF5-B5F741FD475E} 

You can optimize redo transport for best performance. 

Data Guard automatically tunes redo transport to optimize performance. However, if you want more control over the tuning, you can tune the following areas that are used in redo transport: 

  * network configuration 

  * storage configuration 

  * fast recovery area 

  * redo transport configuration 




See the Oracle Data Guard Redo Transport and Network Configuration Best Practices technical brief available on the Oracle Maximum Availability Architecture (MAA) home page at: 

[ ` http://www.oracle.com/goto/maa ` ](http://www.oracle.com/goto/maa)
